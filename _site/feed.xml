<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2024-01-10T21:59:32+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Juryeong’s Blog</title><subtitle>Juryeong's Blog</subtitle><author><name>Kimjuryeong</name></author><entry><title type="html">[혼공컴운] Ch01 정리</title><link href="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch01/" rel="alternate" type="text/html" title="[혼공컴운] Ch01 정리" /><published>2024-01-08T00:00:00+09:00</published><updated>2024-01-08T00:00:00+09:00</updated><id>http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch01</id><content type="html" xml:base="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch01/"><![CDATA[<p><img src="https://velog.velcdn.com/images/ella0106/post/7fc271de-d484-43a2-899a-2687c88eeab2/image.jpg" alt="" /></p>

<h3 id="1-컴퓨터-구조를-알아야-하는-이유">1. 컴퓨터 구조를 알아야 하는 이유</h3>

<ul>
  <li>
    <p>문제 상황을 빠르게 진단할 수 있다.</p>
  </li>
  <li>
    <p>문제 해결의 실마리를 다양하게 찾을 수 있다.</p>
  </li>
  <li>
    <p>문법만으로 알기 어려운 <strong>성능/용량/비용</strong>을 고려하며 개발할 수 있다.</p>
  </li>
  <li>
    <p>컴퓨터 구조를 이해하면 우리는 컴퓨터를 <strong>미지의 대상</strong>에서 <strong>분석의 대상</strong>으로 인식할 수 있다.</p>
  </li>
</ul>

<h3 id="2-컴퓨터-구조의-큰-그림">2. 컴퓨터 구조의 큰 그림</h3>

<ul>
  <li>
    <p>우리가 알아야 하는 컴퓨터 구조 지식은 크게 두 가지이다.</p>

    <p>1.<strong>컴퓨터가 이해하는 정보</strong></p>

    <ul>
      <li>데이터</li>
      <li>명령어</li>
    </ul>

    <p>2.<strong>컴퓨터의 네가지 핵심 부품</strong></p>

    <ul>
      <li>중앙처리장치(CPU)</li>
      <li>주기억장치(메모리)</li>
      <li>보조기억장치</li>
      <li>입출력장치</li>
    </ul>
  </li>
</ul>

<h4 id="1-컴퓨터가-이해하는-정보">1. 컴퓨터가 이해하는 정보</h4>

<ul>
  <li><strong>데이터(data)</strong>
    <ul>
      <li>컴퓨터와 주고받는 숫자, 문자. 이미지, 동영상과 같은 정보나 컴퓨터에 저장된 경로이다.</li>
      <li>0과 1로 데이터를 표현한다.</li>
    </ul>
  </li>
  <li><strong>명령어(instruction)</strong>
    <ul>
      <li>데이터를 움직이고 컴퓨터를 실질적으로 동작시키는 정보이다.</li>
    </ul>
  </li>
</ul>

<h4 id="2-컴퓨터의-4가지-핵심-부품">2. 컴퓨터의 4가지 핵심 부품</h4>

<p><img src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/4f0a106f-dd0f-4cbe-b03b-77a3ca5e9688" alt="스크린샷 2024-01-08 오후 9 37 16" /></p>

<center> 혼자 공부하는 컴퓨터구조 + 운영체제에 삽입된 그림입니다. </center>

<ul>
  <li>
    <p><strong>메모리</strong></p>

    <ul>
      <li>실행되는 프로그램의 명령어와 데이터를 저장하는 부품</li>
      <li>
        <p>프로그램이 실행되려면 반드시 메모리에 저장되어 있어야 한다.</p>
      </li>
      <li>
        <p>크게 <strong>RAM</strong>(Random Access Memory)과 <strong>ROM</strong>(Read Only Memory) 두 가지가 있으며, 메모리는 보통 RAM을 지칭한다.</p>
      </li>
      <li>
        <p>메모리에 저장된 값의 위치는 주소로 알 수 있다.</p>

        <ul>
          <li>저장된 값에 빠르고 효율적으로 접근하기 위해 주소를 사용한다.</li>
        </ul>
      </li>
      <li>가격이 비싸 용량이 적고, 전원이 꺼지면 저장된 내용을 잃는다.</li>
    </ul>
  </li>
  <li>
    <p><strong>중앙처리장치</strong> (CPU; Central  Processing Unit)</p>

    <ul>
      <li>
        <p>메모리에 저장된 명령어를 읽어 들이고, 읽어 들인 명령어를 해석하고, 실행하는 부품이다.</p>
      </li>
      <li>
        <p>CPU 내부 구성 요소 중 가장 중요한 세 가지</p>

        <ul>
          <li>
            <p><strong>산술논리연산장치</strong>(ALU : Arithmetic Logic Unit)</p>

            <p>✔️ 컴퓨터 내부에서 수행되는 대부분의 계산을 수행한다.</p>
          </li>
          <li>
            <p><strong>레지스터</strong>(register)</p>

            <p>✔️ CPU 내부의 작은 임시 저장 장치로, 프로그램을 실행하는 데 필요한 값들을 임시로 저장한다.</p>

            <p>✔️ CPU 안에는 여러 개의 레지스터가 존재하고 각기 다른 이름과 역할을 가지고 있다.</p>
          </li>
          <li>
            <p><strong>제어장치</strong>(CU : Control Unit)</p>

            <p>✔️ 제어 버스를 통해 <strong>제어신호</strong>라는 전기 신호를 보내고 명령어를 해석하는 장치</p>

            <p>​	➡ <strong>제어신호</strong> : 컴퓨터 부품들을 관리하고 작동시키기 위한 일종의 전기 신호</p>

            <p>​	- CPU가 메모리에 <em><u>저장된 값을 읽고</u></em> 싶을 땐 메모리를 향해 <strong>메모리 읽기</strong>라는 제어신호를 보낸다.</p>

            <p>​	- CPU가 메모리에 <em><u>어떤 값을 저장하고</u></em> 싶을 땐 메모리를 향해 <strong>메모리 쓰기</strong>라는 제어신호를 보낸다.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>보조기억장치</strong>(secondary storage)</p>

    <ul>
      <li>
        <p>전원이 꺼져도 저장된 내용을 기억할 수 있는 장치</p>

        <p>➡ 하드 디스크, SSD, USB 메모리, DVD, CD-ROM 등</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>입출력장치</strong>(I/O(input/output) device)</p>
    <ul>
      <li>컴퓨터 외부에 연결되어 컴퓨터 내부와 정보를 교환할 수 있는 장치</li>
      <li>마이크, 스피커, 프린터, 마우스 등</li>
    </ul>
  </li>
</ul>

<h4 id="3-메인보드와-시스템-버스">3. 메인보드와 시스템 버스</h4>

<ul>
  <li><strong>메인보드</strong>(main board)
    <ul>
      <li>여러 컴퓨터 부품을 부착할 수 있는 슬롯과 연결 단자가 있으며, <strong>마더보드</strong>라고도 부른다.</li>
      <li>메인보드에 연결된 부품들은 <strong>버스</strong>라는 통로로 정보를 주고받는다.</li>
    </ul>
  </li>
  <li><strong>시스템 버스</strong>(system bus)
    <ul>
      <li>컴퓨터 네 가지 핵심 부품(CPU, 메모리, 보조기억장치, 입출력장치)을 연결하는 가장 주요한 버스</li>
      <li><strong>주소버스</strong>
        <ul>
          <li>주소를 주고받는 통로</li>
        </ul>
      </li>
      <li><strong>데이터버스</strong>
        <ul>
          <li>명령어와 데이터를 주고받는 통로</li>
        </ul>
      </li>
      <li><strong>제어버스</strong>
        <ul>
          <li>제어신호를 주고받는 통로</li>
        </ul>
      </li>
      <li><strong>메모리 읽기</strong> : CPU가 메모리를 읽을 때
        <ol>
          <li>제어버스로 ‘메모리 읽기’ 제어 신호를 내보낸다.</li>
          <li>주소 버스로 읽고자 하는 주소를 내보낸다.</li>
          <li>메모리가 데이터 버스로 CPU가 요청한 주소에 있는 내용을 내보낸다.</li>
        </ol>
      </li>
      <li><strong>메모리 쓰기</strong> : CPU가 메모리에 어떤 값을 저장하고 싶을 때
        <ol>
          <li>데이터 버스를 통해 메모리에 저장할 값을 내보낸다.</li>
          <li>주소 버스를 통해 저장할 주소를 내보낸다.</li>
          <li>제어 버스를 통해 ‘메모리 쓰기’ 제어 신호를 내보낸다.</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-연습문제">3. 연습문제</h3>

<ol>
  <li>
    <p>컴퓨터가 이해하는 정보에는 <strong>명령어</strong>와  <strong>데이터</strong>가 있습니다.</p>
  </li>
  <li>
    <p>컴퓨터의 네 가지 핵심 부품 중 명령어를 해석하고 실행하는 장치를 고르세요.</p>

    <p>➡ CPU</p>
  </li>
  <li>
    <p>프로그램이 실행되려면 반드시 <strong>메모리</strong>에 저장되어 있어야 합니다.</p>
  </li>
  <li>
    <p>보조기억장치 : 보관할 프로그램 저장</p>

    <p>메모리 : 실행되는 프로그램 저장</p>
  </li>
  <li>
    <p>시스템 버스는 컴퓨터의 핵심 부품을 분리시키는 버스입니다. <br />
➡ 컴퓨터의 핵심 부품을 연결하는 버스이다.</p>
  </li>
</ol>]]></content><author><name>Kimjuryeong</name></author><category term="혼공컴운" /><category term="컴퓨터구조" /><category term="운영체제" /><category term="혼공컴운 연습문제" /><category term="혼공학습단 11기" /><summary type="html"><![CDATA[Ch01 : 컴퓨터 구조 시작하기]]></summary></entry><entry><title type="html">[혼공컴운] Ch02 정리</title><link href="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch02/" rel="alternate" type="text/html" title="[혼공컴운] Ch02 정리" /><published>2024-01-08T00:00:00+09:00</published><updated>2024-01-10T00:00:00+09:00</updated><id>http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch02</id><content type="html" xml:base="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch02/"><![CDATA[<p><img src="https://velog.velcdn.com/images/ella0106/post/7fc271de-d484-43a2-899a-2687c88eeab2/image.jpg" alt="" /></p>

<h3 id="1-0과-1로-숫자를-표현하는-방법">1. 0과 1로 숫자를 표현하는 방법</h3>

<h4 id="1정보단위">1.정보단위</h4>

<ul>
  <li>
    <p><strong>비트</strong>(bit) : 0과 1을 나타내는 가장 정보 단위</p>

    <ul>
      <li>n비트는 <img width="21" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/087d9eae-1257-485e-9b60-ae5767b41803" />가지 정보를 표현할 수 있다.</li>
    </ul>
  </li>
  <li>
    <p><strong>바이트</strong>(byte) : 여덟 개의 비트를 묶은 단위</p>

    <ul>
      <li>1바이트(1byte) = 8비트(8bit)</li>
      <li>1킬로바이트(1kB) = 1,000바이트(1,000byte)</li>
      <li>1메가바이트(1MB) = 1,000킬로바이트(1,000kB)</li>
      <li>1기가바이트(1GB) = 1,000메가바이트(1,000MB)</li>
      <li>1테라바이트(1TB) = 1,000기가바이트(1,000GB)</li>
    </ul>

    <p>✔️ 1kB = 1,024byte, 1MB = 1,024kB.. 이런식으로 표현하는 것은 잘못된 관습</p>

    <p>​	이전 단위를 1,024개씩 묶어 표현한 단위는 kB, MB..가 아닌 KiB, MiB..이다.</p>
  </li>
  <li>
    <p><strong>워드</strong>(ward)  : CPU가 한 번에 처리할 수 있는 데이터 크기</p>
    <ul>
      <li>CPU가 처리할 수 있는 비트 수에 따라 1워드 크기는 달라질 수 있다.</li>
      <li>Ex) CPU가 처리할 수 있는 비트 수 : 16비트 ➡ 1워드 = 16비트</li>
      <li><strong>하프워드</strong>(half word) : 정의된 워드의 절반 크기</li>
      <li><strong>풀 워드</strong>(full word) : 1배 크기, <strong>더블워드</strong> : 2배 크기</li>
      <li>현대 워드 크기의 대부분은 32비트 or 64비트이다.</li>
    </ul>
  </li>
</ul>

<p>​</p>

<h4 id="2-이진법">2. 이진법</h4>

<ul>
  <li>
    <p><strong>이진법</strong>(binary) : 0과 1만으로 모든 숫자를 표현하는 방법</p>

    <ul>
      <li>
        <p>숫자가 1을 넘어가는 시점에서 자리 올림한다.</p>

        <p>Ex) 8 ➡ 1000</p>
      </li>
      <li>
        <p>숫자 10은 십진수로 읽으면 10이지만, 이진수로 읽으면 2이다.</p>

        <p>➡ 이런 혼동을 예방하기 위해 이진수 끝에 (2)를 붙이거나 이진수 앞에 0b를 붙인다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>이진수의 음수 표현</strong></p>

    <ul>
      <li>
        <p><strong>2의 보수</strong> : 0과 1만으로 음수를 표현하는 방법</p>

        <ul>
          <li>사전적 의미 : 어떤 수를 그보다 큰 <img width="21" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/087d9eae-1257-485e-9b60-ae5767b41803" />에서 뺸 값</li>
          <li>쉬운 버전 : 모든 0과 1을 뒤집는다 ➡ 거기에 1을 더한다.</li>
          <li>Ex) 1011 ➡ 0100 ➡ 0101</li>
        </ul>
      </li>
      <li>
        <p><strong>플래그</strong> : 컴퓨터 내부에서 수의 음수와 양수를 구분하기 위해 사용하는 것</p>

        <ul>
          <li>
            <p>실제 이진수만 봐서는 음수인지 양수인지 구분하기 어렵기 때문</p>

            <p>ex) -1011 = 0101;  5(10)= 0101</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="3-십육진법">3. 십육진법</h4>

<ul>
  <li>
    <p><strong>십육진법</strong>(hexadecimal) : 15를 넘어가는 시점에 자리 올림하여 수를 표현하는 방법</p>

    <ul>
      <li>
        <p>이진수와 십육진수 간에 변환이 쉽기 때문에 이진수와 더불어 십육진수도 많이 사용한다.</p>
      </li>
      <li>
        <p>십육진법 체계에서는 10, 11, 12, 13, 14, 15를 A, B, C, D, E, F로 표기한다.</p>
      </li>
      <li>
        <p>왜 굳이 십육진법을 사용할까? ➡ 십육진수는 이진수와 서로 변환하기 쉽기 때문</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>십육진수 ➡ 이진수</strong></p>

    <ul>
      <li>
        <p>십육진수 한 글자를 4비트의 이진수로 간주</p>

        <p>Ex) 1A2B(16) = 0001101000101011</p>

        <ul>
          <li>
            <table>
              <tbody>
                <tr>
                  <td>1</td>
                  <td>A</td>
                  <td>2</td>
                  <td>B   ➡  0001</td>
                  <td>1010</td>
                  <td>0010</td>
                  <td>1011</td>
                </tr>
              </tbody>
            </table>
          </li>
        </ul>
      </li>
      <li>
        <p>이진수 ➡ 십육진수는 해당 과정을 반대로 적용하면 된다</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="4-확인-문제">4. 확인 문제</h4>

<ol>
  <li>2000MB = <strong>2</strong>GB</li>
  <li>1024bit는 1byte와 같습니다. ➡ <strong>8bit는 1byte와 같습니다.</strong></li>
  <li>1101(2)의 음수를 2의 보수 표현법으로
    <ul>
      <li>1101 ➡ 0010 ➡ 0011</li>
    </ul>
  </li>
  <li>DA(16)를 이진수로 표현
    <ul>
      <li>D(16) = 1100(2), A(16) = 1010(2)</li>
      <li>DA(16) = 11001010(2)</li>
    </ul>
  </li>
  <li>이진수와 더불어 십육진수가 많이 사용되는 대표적인 이유
    <ul>
      <li>이진수와 십육진수 간의 변환이 쉽기 때문이다</li>
    </ul>
  </li>
</ol>

<h3 id="2-0과-1로-문자를-표현하는-방법">2. 0과 1로 문자를 표현하는 방법</h3>

<h4 id="1-문자-집합과-인코딩">1. 문자 집합과 인코딩</h4>

<ul>
  <li><strong>문자집합</strong>(character set) : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음
    <ul>
      <li>컴퓨터는 문자 집합에 속해 있는 문자를 이해할 수 있고, 속해 있지 않은 문자는 이해할 수 없다.</li>
      <li><strong>문자 인코딩</strong> : 문자 집합에 속한 문자를 컴퓨터가 이해할 수 있는 0과 1로 변환하는 과정</li>
      <li><strong>문자 디코딩</strong> : 인코딩의 반대, 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정</li>
    </ul>
  </li>
</ul>

<h4 id="2-아스키-코드">2. 아스키 코드</h4>

<ul>
  <li><strong>아스키</strong> (ASCII) : 초창기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자, 일부 특수 문자를 포함
    <ul>
      <li><strong>아스키 문자</strong>(아스키 문자 집합에 속한 문자)들은 각각 7비트로 표현된다.
        <ul>
          <li>7비트로 표현할 수 있는 정보의 가짓수 : <img src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/c323aade-8bd3-4584-9aa3-dfe43c5b2b8b" alt="image" />= 128개</li>
          <li>아스키 문자들은 128(0~127)개의 숫자 중 하나의 고유한 수에 일대일로 대응된다.</li>
        </ul>
      </li>
      <li><strong>아스키 코드</strong> : 아스키 문자에 대응된 고유한 수
        <ul>
          <li>아스키 문자를 아스키 코드로 인코딩해 0과 1로 표현할 수 있다.</li>
          <li>한글 뿐만 아니라 아스키 문자 집합 외의 문자, 특수문자도 표현할 수 없다는 단점이 있다.</li>
        </ul>
      </li>
      <li><strong>확장 아스키</strong> : 다양한 문자 표현을 위해 아스키 코드에 1비트를 추가한 것(8비트)
        <ul>
          <li>표현 가능한 문자의 수는 256개여서 다양한 문자 표현을 하기엔 부족했다.</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="3-euc-kr">3. EUC-KR</h4>

<ul>
  <li>
    <p><strong>한글 인코딩</strong></p>

    <ul>
      <li>
        <p>한글은 각 음절 하나하나가 초성, 중성, 종성의 조합으로 이루어져 있기 때문에 한글 인코딩에는 두 가지 방식이 존재한다.</p>
      </li>
      <li>
        <p><strong>완성형 인코딩</strong> : 하나의 글자에 고유한 코드를 부여하는 인코딩 방식</p>

        <p>Ex) ‘가’ = 1, ‘나’ = 2 …</p>
      </li>
      <li>
        <p><strong>조합형 인코딩</strong> : 초성, 중성, 종성에 해당하는 코드를 합하여 하나의 글자 코드를 만드는 인코딩 방식</p>

        <p>Ex) ‘ㄱ’ + ‘ㅏ’ + ‘ㅇ’ ➡ 0010 + 0011 + 0011 00011 ➡ 0010 0011 0001 00011</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>EUC-KR</strong> : 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식</p>

    <ul>
      <li>
        <p>초성, 중성, 종성이 모두 결합된 한글 글자에 2바이트 크기의 코드를 부여한다.</p>
      </li>
      <li>
        <p>EUC-KR로 인코딩한 한글 한 글자를 표현하려면 16비트가 필요하다.</p>
      </li>
      <li>
        <p>모든 한글을 표현할 수 없기 때문에 글자 깨짐 현상이 발생하기도 한다.</p>

        <p>➡ 이런 문제를 해결하기 위해 EUC-KR의 확장된 버전으로 마이크로소프트의 <strong>CP949</strong>가 등장했으나 한글 전체를 표현하기에 넉넉한 양은 아니다.</p>
      </li>
      <li>
        <p><img src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/bc3dc74e-f7f6-4c30-bcd4-bf54bed7fe77" alt="image" /></p>
      </li>
    </ul>
  </li>
</ul>

<p>출처 : https://blog.naver.com/bbmobile/221360230141</p>

<h4 id="4-유니코드와-utf-8">4. 유니코드와 UTF-8</h4>

<ul>
  <li>
    <p><strong>유니코드</strong> : 여러 나라의 문자를 광범위하게 표현할 수 있는 통일된 문자 집합</p>

    <ul>
      <li>유니코드 문자 집합에서는 각 문자마다 고유한 값이 부여된다.
        <ul>
          <li>유니코드 글자에 부여된 값 앞에 U+D55C처럼 U+ 문자열이 붙는 것은 십육진수로 표현할 때 사용</li>
        </ul>
      </li>
      <li>글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 다양한 방법으로 인코딩한다.
        <ul>
          <li><strong>UTF-8, UTF-16, UTF-32</strong>… ➡ 유니코드 문자에 부여된 값을 인코딩하는 방식</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>UTF-8</strong> 방식</p>

    <ul>
      <li>유니코드 문자에 부여된 값의 범위에 따라 1바이트부터 4바이트까지의 인코딩 결과를 만들어 낸다.</li>
    </ul>

    <p><img width="979" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/b24a80c1-922f-4a64-98a5-72d460e3096a" /></p>
  </li>
</ul>

<p>출처 : 혼자 공부하는 컴퓨터 구조 + 운영체제 73p</p>

<h4 id="5-확인-문제">5. 확인 문제</h4>

<ol>
  <li>아스키 코드 디코딩
    <ul>
      <li>104 111 110 103 111 110 103 ➡ <strong>hongong</strong></li>
    </ul>
  </li>
  <li>EUC-KR 인코딩에 대한 설명이 틀린 것
    <ul>
      <li>조합형 인코딩 방식입니다. ➡ 완성형 인코딩 방식입니다.</li>
    </ul>
  </li>
  <li>유니코드 문자 집합에서 ‘안녕’을 UTF-8로 인코딩한 값
    <ul>
      <li>3byte 인코딩</li>
      <li>‘안’ ➡ C548(16) = 1100 0101 0100 1000(2) ➡ 11101100 10010101 10001000</li>
      <li>‘녕 ‘ ➡ B155(16) = 1011 0001 0101 0101(2) ➡ 11101011 10000101 10010101</li>
    </ul>
  </li>
</ol>]]></content><author><name>Kimjuryeong</name></author><category term="혼공컴운" /><category term="컴퓨터구조" /><category term="운영체제" /><category term="혼공컴운 연습문제" /><category term="혼공학습단 11기" /><summary type="html"><![CDATA[Ch02 : 데이터]]></summary></entry><entry><title type="html">[혼공컴운] Ch03 정리</title><link href="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch03/" rel="alternate" type="text/html" title="[혼공컴운] Ch03 정리" /><published>2024-01-08T00:00:00+09:00</published><updated>2024-01-10T00:00:00+09:00</updated><id>http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch03</id><content type="html" xml:base="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/Ch03/"><![CDATA[<p><img src="https://velog.velcdn.com/images/ella0106/post/7fc271de-d484-43a2-899a-2687c88eeab2/image.jpg" alt="" /></p>

<h3 id="1-소스-코드와-명령어">1. 소스 코드와 명령어</h3>

<h4 id="1-고급-언어와-저급-언어">1. 고급 언어와 저급 언어</h4>

<ul>
  <li>
    <p><strong>고급 언어</strong>(high-level programming language)</p>

    <ul>
      <li>프로그램을 만들 때 컴퓨터가 이해하는 언어가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어</li>
      <li>C, C++, java, Python..</li>
    </ul>
  </li>
  <li>
    <p><strong>저급 언어</strong>(low-level programming language)</p>

    <ul>
      <li>
        <p>컴퓨터가 직접 이해하고 실행할 수 있는 언어 ➡ 기계어, 어셈블리어</p>
      </li>
      <li>
        <p>고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어(명령어)로 변환되어야 한다.</p>
      </li>
      <li>
        <p><strong>기계어</strong>(machine code) : 0과1로 이루어진 명령어 모음</p>

        <ul>
          <li>이진수로 나열하면 너무 길어지기 때문에 십육진수로 표현하기도 한다.</li>
        </ul>
      </li>
      <li>
        <p><strong>어셈블리어</strong>(assembly language) :</p>

        <ul>
          <li>기계어를 읽기 편한 형태로 번역한 언어</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="2-컴파일-언어와-인터프리터-언어">2. 컴파일 언어와 인터프리터 언어</h4>

<ul>
  <li>
    <p>개발자들이 고급 언어로 작성한 소스 코드는 저급 언어로 변환되어 실행된다.</p>
  </li>
  <li>
    <p>고급언어에서 저급언어로 변환되는 방식 ➡ <strong>컴파일 방식</strong>, <strong>인터프리트 방식</strong></p>
  </li>
  <li>
    <p><strong>컴파일 언어</strong>(compile language) : 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어</p>

    <ul>
      <li>
        <p>대표 언어 : C</p>
      </li>
      <li>
        <p><strong>컴파일</strong>(compile) : 컴파일 언어로 작성된 소스 코드의 코드 전체가 저급 언어로 변환되는 과정</p>
      </li>
      <li>
        <p><strong>컴파일러</strong>(compiler) : 컴파일을 수행해 주는 도구</p>

        <ul>
          <li>코드 내에 오류가 하나라도 있으면 컴파일이 불가능</li>
        </ul>
      </li>
      <li>
        <p><strong>목적코드</strong>(object code) : 컴파일러를 통해 저급 언어로 변환된 코드</p>
      </li>
      <li>
        <p>소스 코드(고급 언어) ➡ 컴파일러(컴파일) ➡ 목적 코드(저급 언어)</p>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>인터프리터 언어</strong>(interpreter language) : 인터프리터에 의해 소스 코드를 한 줄씩 저급 언어로 변환하여 실행하는 고급 언어</p>

    <ul>
      <li>대표 언어 Python</li>
      <li><strong>인터프리터</strong>(interpreter) : 컴퓨터와 대화하듯 한 줄씩 실행
        <ul>
          <li>N번째 줄에 문법 오류가 있어도 N-1번째까지는 올바르게 수행</li>
        </ul>
      </li>
      <li>한 줄씩 저급 언어로 해석하며 실행하기 때문에 컴파일 언어보다 느리다.</li>
    </ul>
  </li>
</ul>

<h4 id="3-목적-파일-vs-실행-파일">3. 목적 파일 vs 실행 파일</h4>

<ul>
  <li>
    <p><strong>목적 파일</strong> : 목적 코드로 이루어진 파일</p>
  </li>
  <li>
    <p><strong>실행 파일</strong> : 실행 코드로 이루어진 파일 ➡ 윈도우의 .exe 확장자를 가진 파일</p>
  </li>
  <li>
    <p><strong>링킹</strong> : 목적코드가 실행 파일이 되기 위해 거치는 작업</p>
  </li>
</ul>

<h4 id="4-확인-문제">4. 확인 문제</h4>

<ol>
  <li>
    <p>고급 언어가 아닌 것 : 컴파일 언어, 인터프리트 언어</p>
  </li>
  <li>
    <p>일반적으로 컴파일 언어보다 인터프리터 언어가 더 빠릅니다.</p>

    <p>➡ 일반적으로 인터프리터 언어보다 컴파일 언어가 더 빠릅니다.</p>
  </li>
</ol>

<h3 id="2-명령어의-구조">2. 명령어의 구조</h3>

<h4 id="1-연산-코드와-오퍼랜드">1. 연산 코드와 오퍼랜드</h4>

<ul>
  <li>
    <p><strong>명령어</strong>(instruction) : 연산 코드와 오퍼랜드로 구성</p>
  </li>
  <li>
    <p><strong>오퍼랜드</strong>(<strong>피연산자</strong>) : 연산에 사용할 데이터가 저장된 위치</p>

    <ul>
      <li>
        <p><strong>오퍼랜드 필드</strong>(<strong>주소 필드</strong>) : 오퍼랜드가 담기는 영역</p>

        <ul>
          <li>연산에 사용할 데이터를 직접 명시하기 보다는, 연산에 사용할 데이터가 저장된 위치(레지스터 이름)가  담긴다.</li>
        </ul>
      </li>
      <li>
        <p>명령어 안에 하나도 없을 수도 있고, 한 개만 있을 수도 있고, 두 개 또는 세 개등 여러개 가능</p>

        <ul>
          <li>
            <p><strong>0-주소 명령어</strong> : 오퍼랜드가 하나도 없는 명령어</p>
          </li>
          <li>
            <p><strong>주소 명령어</strong> : 오퍼랜드가 하나인 명령어 , <strong>2-주소 명령어</strong> : 두 개인 명령어, <strong>3-주소 명령어</strong> : 세 개인 명령어</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>연산 코드</strong>(<strong>연산자</strong>) : 명령어가 수행할 연산,</p>

    <ul>
      <li>
        <p><strong>연산 코드 필드</strong> : 연산 코드 필드</p>
      </li>
      <li>
        <p>가장 기본적인 연산 코드 유형</p>

        <ul>
          <li>
            <p><strong>데이터 전송</strong></p>

            <p>➡ MOVE : 데이터를 옮겨라</p>

            <p>➡ STORE : 메모리에 저장하라</p>

            <p>➡ LOAD(FETCH) : 메모리에서 CPU로 데이터를 가져와라</p>

            <p>➡ PUSH : 스택에 데이터를 저장하라</p>

            <p>➡ POP : 스택의 최상단 데이터를 가져와라</p>
          </li>
          <li>
            <p><strong>산술/논리 연산</strong></p>

            <p>➡ ADD / SUBTRACT / MULTIPLY / DIVIDE : 덧셈 / 뺼셈/ 곱셈/ 나눗셈을 수행하라</p>

            <p>➡ INCREMENT / DECREMENT : 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라</p>

            <p>➡ AND / OR / NOT : AND / OR / NOT 연산을 수행하라</p>

            <p>➡ COMPAREA : 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라</p>
          </li>
          <li>
            <p><strong>제어 흐름 변경</strong></p>

            <p>➡ JUMP : 특정 주소로 실행 순서를 옮겨라</p>

            <p>➡ CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라</p>

            <p>➡ HALT : 프로그램의 실행을 멈춰라</p>

            <p>➡ CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라</p>

            <p>➡ RETURN CALL : CALL을 호출할 때 저장했던 주소로 돌아가라</p>
          </li>
          <li>
            <p><strong>입출력 제어</strong></p>

            <p>➡ READ(INPUT) : 특정 입출력 장치로부터 데이터를 읽어라</p>

            <p>➡ WRITE(OUTPUT) : 특정 입출력 장치로 데이터를 써라</p>

            <p>➡ START IO : 입출력 장치를 시작하라</p>

            <p>➡ TEST IO : 입출력 장치의 상태를 확인하라</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="2-주소-지정-방식">2. 주소 지정 방식</h4>

<ul>
  <li>
    <p>오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 이유 ➡ 명령어의 길이 때문이다.</p>

    <p>ex) 명령어 1 = n비트, 연산 코드 필드 = m비트</p>

    <ul>
      <li>
        <p>1-주소 명령어</p>

        <p><img width="493" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/f098d1a4-e0b3-4c72-85a6-e2a5083ff5de" /></p>

        <ul>
          <li>오퍼랜드 필드의 길이 = n-m비트</li>
          <li>1-주소 명령어에서 표현할 수 있는 데이터 크기 :  2^12 = 4096</li>
        </ul>
      </li>
      <li>
        <p>2-주소 명령어</p>

        <p><img width="381" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/2ede39a5-be2c-4c61-bad8-547bc51efa2b" /></p>

        <ul>
          <li>2-주소 명령어에서 표현할 수 있는 데이터 크기 : 2^6 = 64</li>
        </ul>
      </li>
      <li>
        <p>3-주소 명령어</p>

        <p><img width="408" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/8e7b414e-05c9-4225-b566-c30d230356be" /></p>

        <ul>
          <li>3-주소 명령어에서 표현할 수 있는 데이터 크기 : 2^4 = 16</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>만약 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.</p>

    <p>Ex) 한 주소에 16비트를 저장할 수 있는 메모리가 있을 때</p>

    <p>​	 ➡ 메모리 안에 데이터를 저장하고, 오퍼랜드 필드 안에 해당 메모리 주소를 명시</p>

    <p>​	 ➡ 표현할 수 있는 정보의 가짓수 : 2^16</p>

    <p>​	<img src="/Users/juryeong/Library/Application Support/typora-user-images/image-20240110203133958.png" alt="image-20240110203133958" style="zoom:50%;" /> 그림 1</p>

    <p>Ex) 오퍼랜드 필드에 메모리 주소가 아닌 레지스터의 이름을 명시할 때</p>

    <p>​	<img width="309" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/a32cc93e-ac9d-4197-b173-a516824a5571" />그림 2</p>
  </li>
  <li>
    <p><strong>유효주소</strong>(effective address) : 연산의 대상이 되는 데이터가 저장된 위치</p>

    <ul>
      <li>그림1의 유효주소 : 10번지</li>
      <li>그림2의 유효주소 : 레지스터 R1</li>
    </ul>
  </li>
  <li>
    <p><strong>주소 지정 방식</strong>(addressing mode): 연산에 사용할 데이터의 위치를 찾는 방법(유효 주소를 찾는 방법)</p>
  </li>
</ul>

<h4 id="2-1-대표적인-주소-지정-방식">2-1. 대표적인 주소 지정 방식</h4>

<ul>
  <li>
    <p><strong>즉시 주소 지정 방식</strong>(immediate addressing mode)</p>

    <ul>
      <li>연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식</li>
    </ul>

    <p><img width="417" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/83fc3f1e-8230-40a1-9eb0-5929355a6076" /></p>

    <ul>
      <li>
        <p><strong>장점</strong></p>

        <ul>
          <li>연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없어, 이하 설명할 주소 지정 방식들보다 빠르다.</li>
        </ul>
      </li>
      <li>
        <p><strong>단점</strong></p>

        <ul>
          <li>표현할 수 있는 데이터의 크기가 작아진다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>직접 주소 지정 방식</strong>(direct addressing mode)</p>

    <ul>
      <li>오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식</li>
    </ul>

    <p><img width="520" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/5970b3f8-ba42-4fed-b0e7-9ab164c52680" /></p>

    <ul>
      <li>
        <p><strong>장점</strong></p>

        <ul>
          <li>오퍼랜드 필드에서 표현할 수 있는 데이터의 크기는 <strong>즉시 주소 지정 방식</strong>보다 크다</li>
        </ul>
      </li>
      <li>
        <p><strong>단점</strong></p>

        <ul>
          <li>
            <p>유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 줄어들었다.</p>

            <p>➡ 표현할 수 있는 오퍼랜드 필드의 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있다.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>간접 주소 지정 방식</strong>(indirect addressing mode)</p>

    <ul>
      <li>유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식</li>
    </ul>

    <p><img width="686" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/8cf734b8-83ae-4fce-98f7-68002ecbbdc6" /></p>

    <ul>
      <li>
        <p><strong>장점</strong></p>

        <ul>
          <li><strong>직접 주소 지정 방식</strong>보다 표현할 수 있는 유효 주소의 범위가 더 넓어졌다.</li>
        </ul>
      </li>
      <li>
        <p><strong>단점</strong></p>

        <ul>
          <li>두 번의 메모리 접근이 필요하기 때문에 앞선 주소 지정 방식들보다 일반적으로 느리다.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>레지스터 주소 지정 방식</strong>(register addressing mode)</p>

    <ul>
      <li>연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식</li>
    </ul>

    <p><img width="614" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/5644c243-1c52-443f-93e3-54d41d00cd14" /></p>

    <ul>
      <li>
        <p>직접 주소 지정 방식과 비슷하다.</p>
      </li>
      <li>
        <p>일반적으로 CPU외부에 있는 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다.</p>
      </li>
      <li>
        <p><strong>장점</strong></p>

        <ul>
          <li><strong>직접 주소 지정 방식</strong>보다 빠르게 데이터에 접근할 수 있다.</li>
        </ul>
      </li>
      <li>
        <p><strong>단점</strong></p>

        <ul>
          <li>표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.(<strong>직접 주소 지정 방식</strong>과 유사)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>레지스터 간접 주소 지정 방식</strong>(register indirect addreseing mode)</p>

    <ul>
      <li>연산에 사용할 데이터를 메모리에 저장하고 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방식</li>
    </ul>

    <p><img width="745" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/abc36bfa-8a8b-4f94-b864-c3ceba34b089" /></p>

    <ul>
      <li>
        <p><strong>장점</strong></p>

        <ul>
          <li>
            <p>유효 주소를 찾는 과정이 <strong>간접 주소 지정 방식</strong>과 비슷하지만, 메모리에 접근하는 횟수가 한 번으로 줄어든다.</p>
          </li>
          <li>
            <p><strong>간접 주소 지정 방식</strong>보다 빠르다.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p><strong>정리</strong></p>

    <ul>
      <li>
        <p><strong>주소 지정 방식</strong> : 연산에 사용할 데이터를 찾는 방법</p>
      </li>
      <li>
        <p><strong>유효 주소</strong> : 연산에 사용할 데이터가 저장된 위치</p>
      </li>
      <li>
        <p><strong>대표적인 주소 저장 방식</strong></p>

        <ul>
          <li>
            <p>즉시 주소 저장 방식 : 연산에 사용할 데이터</p>
          </li>
          <li>
            <p>직접 주소 지정 방식 : 유효주소(메모리 주소)</p>
          </li>
          <li>
            <p>간접 주소 지정 방식 : 유효 주소의 주소</p>
          </li>
          <li>
            <p>레지스터 주소 지정 방식 : 유효 주소(레지스터 이름)</p>
          </li>
          <li>
            <p>레지스터 간접 주소 지정 방식 : 유효 주소를 지정할 레지스터</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="3-스택과-큐">3. 스택과 큐</h4>

<ul>
  <li><strong>스택</strong>
    <ul>
      <li><strong>LIFO</strong>:  후입선출 방식</li>
      <li><strong>PUSH</strong>: 스택에 새로운 데이터를 저장하는 명령어</li>
      <li><strong>POP</strong>: 스택에 저장된 데이터를 꺼내는 명령어</li>
    </ul>
  </li>
  <li><strong>큐</strong>
    <ul>
      <li>양쪽이 뚫려 있는 저장 공간</li>
      <li><strong>FIFO</strong>: 선입선출 방식</li>
    </ul>
  </li>
</ul>

<h4 id="4-확인-문제-1">4. 확인 문제</h4>

<ol>
  <li>
    <p>명령어에 대한 설명이 틀린 것</p>

    <ul>
      <li>
        <p>연산 코드와 필드에는 메모리 주소만 담을 수 있습니다.</p>

        <p>➡ 연산 코드와 필드에는 메모리 주소 이외에도 다양한 정보를 담을 수 있습니다.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>메모리 <strong>5번지</strong> 속 <strong>100</strong>이라는 값을 CPU로 가져온다.</p>
  </li>
</ol>]]></content><author><name>Kimjuryeong</name></author><category term="혼공컴운" /><category term="컴퓨터구조" /><category term="운영체제" /><category term="혼공컴운 연습문제" /><category term="혼공학습단 11기" /><summary type="html"><![CDATA[Ch03 : 명령어]]></summary></entry><entry><title type="html">[혼공컴운] 1주차 미션</title><link href="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/1.week1-CO/" rel="alternate" type="text/html" title="[혼공컴운] 1주차 미션" /><published>2024-01-07T00:00:00+09:00</published><updated>2024-01-07T00:00:00+09:00</updated><id>http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/1.week1-CO</id><content type="html" xml:base="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%BB%B4%EC%9A%B4/1.week1-CO/"><![CDATA[<h3 id="1-p51-65-확인-문제-3번-풀고-인증하기기본-미션">1. P.51, 65 확인 문제 3번 풀고 인증하기(기본 미션)</h3>

<ol>
  <li>
    <p>프로그램이 실행되려면 반드시 (<strong>메모리</strong>)에 저장되어 있어야 합니다.</p>
  </li>
  <li>
    <p>1101 ➡️ 0010 ➡️ 0011</p>
    <ul>
      <li>1101(2)을 음수로 표현한 값은 <strong>0011</strong>입니다.</li>
    </ul>
  </li>
</ol>

<h3 id="2-p100-스택과-큐의-개념을-정리하기선택미션">2. P100. 스택과 큐의 개념을 정리하기(선택미션)</h3>

<h4 id="1-스택">1. 스택</h4>

<ul>
  <li>한쪽 끝이 막혀 있는 저장 공간</li>
  <li><strong>LIFO</strong> : 후입선출 방식</li>
  <li>PUSH : 스택에 새로운 데이터를 저장하는 명령어</li>
  <li>POP : 스택에 저장된 데이터를 꺼내는 명령어</li>
</ul>

<h4 id="2-큐">2. 큐</h4>

<ul>
  <li>양쪽이 뚫려 있는 저장 공간</li>
  <li><strong>FIFO</strong> : 선입선출 방식</li>
</ul>]]></content><author><name>Kimjuryeong</name></author><category term="혼공컴운" /><category term="컴퓨터구조" /><category term="운영체제" /><category term="혼공컴운 연습문제" /><category term="혼공학습단 11기" /><summary type="html"><![CDATA[Ch01 ~ Ch03]]></summary></entry><entry><title type="html">[혼공자바] 1주차 과제</title><link href="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%9E%90%EB%B0%94/1.week1/" rel="alternate" type="text/html" title="[혼공자바] 1주차 과제" /><published>2024-01-06T00:00:00+09:00</published><updated>2024-01-07T00:00:00+09:00</updated><id>http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%9E%90%EB%B0%94/1.week1</id><content type="html" xml:base="http://localhost:4000/%ED%98%BC%EA%B3%B5%EC%9E%90%EB%B0%94/1.week1/"><![CDATA[<h3 id="1-jdk-설치화면-인증하기-기본미션">1. JDK 설치화면 인증하기 (기본미션)</h3>

<p><img src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/31dd98c3-14c6-48a3-b878-637880f9dacc" alt="image" /></p>

<h3 id="2-p88-확인문제-9번-선택미션">2. p.88 확인문제 9번 (선택미션)</h3>

<p>1.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">var1</span> <span class="o">=</span> <span class="mi">2L</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">var2</span> <span class="o">=</span> <span class="mf">1.8f</span><span class="o">;</span>
        <span class="kt">double</span> <span class="n">var3</span> <span class="o">=</span> <span class="mf">2.5</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">var4</span> <span class="o">=</span> <span class="s">"3.9"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">var1</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">var2</span>  <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">var3</span> <span class="o">+</span> <span class="nc">Float</span><span class="o">.</span><span class="na">parseFloat</span><span class="o">(</span><span class="n">var4</span><span class="o">));</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>2.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">var1</span> <span class="o">=</span> <span class="mi">2L</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">var2</span> <span class="o">=</span> <span class="mf">1.8f</span><span class="o">;</span>
        <span class="kt">double</span> <span class="n">var3</span> <span class="o">=</span> <span class="mf">2.5</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">var4</span> <span class="o">=</span> <span class="s">"3.9"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">var1</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">var2</span>  <span class="o">+</span> <span class="n">var3</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Float</span><span class="o">.</span><span class="na">parseFloat</span><span class="o">(</span><span class="n">var4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>3.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">var1</span> <span class="o">=</span> <span class="mi">2L</span><span class="o">;</span>
        <span class="kt">float</span> <span class="n">var2</span> <span class="o">=</span> <span class="mf">1.8f</span><span class="o">;</span>
        <span class="kt">double</span> <span class="n">var3</span> <span class="o">=</span> <span class="mf">2.5</span><span class="o">;</span>
        <span class="nc">String</span> <span class="n">var4</span> <span class="o">=</span> <span class="s">"3.9"</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="n">var1</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)(</span><span class="n">var2</span>  <span class="o">+</span> <span class="n">var3</span><span class="o">)</span> <span class="o">+</span> <span class="o">(</span><span class="kt">int</span><span class="o">)</span><span class="nc">Double</span><span class="o">.</span><span class="na">parseDouble</span><span class="o">(</span><span class="n">var4</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">result</span><span class="o">);</span>

    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>Kimjuryeong</name></author><category term="혼공자바" /><category term="Java" /><category term="혼공자바" /><category term="혼공자바 연습문제" /><category term="혼공학습단 11기" /><summary type="html"><![CDATA[Ch01 ~ Ch03]]></summary></entry></feed>