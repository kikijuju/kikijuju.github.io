---
title: "[혼공컴운] Ch02 정리"
excerpt: "Ch02 : 데이터"
toc: true
toc_sticky: true
published: true

categories:
  - 혼공컴운
tags:
  - 컴퓨터구조
  - 운영체제
  - 혼공컴운 연습문제
  - 혼공학습단 11기 
last_modified_at: 2024-01-10
---

![](https://velog.velcdn.com/images/ella0106/post/7fc271de-d484-43a2-899a-2687c88eeab2/image.jpg)



### 1. 0과 1로 숫자를 표현하는 방법 

#### 1.정보단위

- **비트**(bit) : 0과 1을 나타내는 가장 정보 단위

  - n비트는 <img width="21" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/087d9eae-1257-485e-9b60-ae5767b41803">가지 정보를 표현할 수 있다. 

    

- **바이트**(byte) : 여덟 개의 비트를 묶은 단위 

  - 1바이트(1byte) = 8비트(8bit)
  - 1킬로바이트(1kB) = 1,000바이트(1,000byte)
  - 1메가바이트(1MB) = 1,000킬로바이트(1,000kB)
  - 1기가바이트(1GB) = 1,000메가바이트(1,000MB)
  - 1테라바이트(1TB) = 1,000기가바이트(1,000GB)

  ✔️ 1kB = 1,024byte, 1MB = 1,024kB.. 이런식으로 표현하는 것은 잘못된 관습

  ​	이전 단위를 1,024개씩 묶어 표현한 단위는 kB, MB..가 아닌 KiB, MiB..이다.

  

- **워드**(ward)  : CPU가 한 번에 처리할 수 있는 데이터 크기
  - CPU가 처리할 수 있는 비트 수에 따라 1워드 크기는 달라질 수 있다. 
  - Ex) CPU가 처리할 수 있는 비트 수 : 16비트 ➡ 1워드 = 16비트
  - **하프워드**(half word) : 정의된 워드의 절반 크기 
  - **풀 워드**(full word) : 1배 크기, **더블워드** : 2배 크기 
  - 현대 워드 크기의 대부분은 32비트 or 64비트이다. 

​		

#### 2. 이진법

- **이진법**(binary) : 0과 1만으로 모든 숫자를 표현하는 방법

  - 숫자가 1을 넘어가는 시점에서 자리 올림한다.

    Ex) 8 ➡ 1000

  - 숫자 10은 십진수로 읽으면 10이지만, 이진수로 읽으면 2이다. 

    ➡ 이런 혼동을 예방하기 위해 이진수 끝에 (2)를 붙이거나 이진수 앞에 0b를 붙인다.
    
    

- **이진수의 음수 표현** 

  - **2의 보수** : 0과 1만으로 음수를 표현하는 방법

    - 사전적 의미 : 어떤 수를 그보다 큰 <img width="21" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/087d9eae-1257-485e-9b60-ae5767b41803">에서 뺸 값
    - 쉬운 버전 : 모든 0과 1을 뒤집는다 ➡ 거기에 1을 더한다.
    - Ex) 1011 ➡ 0100 ➡ 0101

  - **플래그** : 컴퓨터 내부에서 수의 음수와 양수를 구분하기 위해 사용하는 것 

    - 실제 이진수만 봐서는 음수인지 양수인지 구분하기 어렵기 때문 

      ex) -1011 = 0101;  5(10)= 0101

#### 3. 십육진법

- **십육진법**(hexadecimal) : 15를 넘어가는 시점에 자리 올림하여 수를 표현하는 방법

  - 이진수와 십육진수 간에 변환이 쉽기 때문에 이진수와 더불어 십육진수도 많이 사용한다. 

  - 십육진법 체계에서는 10, 11, 12, 13, 14, 15를 A, B, C, D, E, F로 표기한다. 

  - 왜 굳이 십육진법을 사용할까? ➡ 십육진수는 이진수와 서로 변환하기 쉽기 때문

    

- **십육진수 ➡ 이진수**

  - 십육진수 한 글자를 4비트의 이진수로 간주 

    Ex) 1A2B(16) = 0001101000101011

    - 1 | A | 2 | B   ➡  0001 | 1010 | 0010 | 1011

  - 이진수 ➡ 십육진수는 해당 과정을 반대로 적용하면 된다 

#### 4. 확인 문제

1. 2000MB = **2**GB
2. 1024bit는 1byte와 같습니다. ➡ **8bit는 1byte와 같습니다.**
3. 1101(2)의 음수를 2의 보수 표현법으로
   - 1101 ➡ 0010 ➡ 0011
4. DA(16)를 이진수로 표현
   - D(16) = 1100(2), A(16) = 1010(2)
   - DA(16) = 11001010(2)
5. 이진수와 더불어 십육진수가 많이 사용되는 대표적인 이유
   - 이진수와 십육진수 간의 변환이 쉽기 때문이다 

### 2. 0과 1로 문자를 표현하는 방법

####  1. 문자 집합과 인코딩

- **문자집합**(character set) : 컴퓨터가 인식하고 표현할 수 있는 문자의 모음  
  - 컴퓨터는 문자 집합에 속해 있는 문자를 이해할 수 있고, 속해 있지 않은 문자는 이해할 수 없다. 
  - **문자 인코딩** : 문자 집합에 속한 문자를 컴퓨터가 이해할 수 있는 0과 1로 변환하는 과정
  - **문자 디코딩** : 인코딩의 반대, 0과 1로 이루어진 문자 코드를 사람이 이해할 수 있는 문자로 변환하는 과정

#### 2. 아스키 코드

- **아스키** (ASCII) : 초창기 문자 집합 중 하나로, 영어 알파벳과 아라비아 숫자, 일부 특수 문자를 포함
  - **아스키 문자**(아스키 문자 집합에 속한 문자)들은 각각 7비트로 표현된다.
    - 7비트로 표현할 수 있는 정보의 가짓수 : ![image](https://github.com/kikijuju/kikijuju.github.io/assets/114811246/c323aade-8bd3-4584-9aa3-dfe43c5b2b8b)= 128개
    - 아스키 문자들은 128(0~127)개의 숫자 중 하나의 고유한 수에 일대일로 대응된다.
  - **아스키 코드** : 아스키 문자에 대응된 고유한 수 
    - 아스키 문자를 아스키 코드로 인코딩해 0과 1로 표현할 수 있다.
    - 한글 뿐만 아니라 아스키 문자 집합 외의 문자, 특수문자도 표현할 수 없다는 단점이 있다.
  - **확장 아스키** : 다양한 문자 표현을 위해 아스키 코드에 1비트를 추가한 것(8비트)
    - 표현 가능한 문자의 수는 256개여서 다양한 문자 표현을 하기엔 부족했다.

#### 3. EUC-KR

- **한글 인코딩**

  - 한글은 각 음절 하나하나가 초성, 중성, 종성의 조합으로 이루어져 있기 때문에 한글 인코딩에는 두 가지 방식이 존재한다. 

  - **완성형 인코딩** : 하나의 글자에 고유한 코드를 부여하는 인코딩 방식

    Ex) '가' = 1, '나' = 2 ...

  - **조합형 인코딩** : 초성, 중성, 종성에 해당하는 코드를 합하여 하나의 글자 코드를 만드는 인코딩 방식

    Ex) 'ㄱ' + 'ㅏ' + 'ㅇ' ➡ 0010 + 0011 + 0011 00011 ➡ 0010 0011 0001 00011

    


- **EUC-KR** : 한글을 2바이트 크기로 인코딩할 수 있는 완성형 인코딩 방식

  - 초성, 중성, 종성이 모두 결합된 한글 글자에 2바이트 크기의 코드를 부여한다.

  - EUC-KR로 인코딩한 한글 한 글자를 표현하려면 16비트가 필요하다. 

  - 모든 한글을 표현할 수 없기 때문에 글자 깨짐 현상이 발생하기도 한다. 

     ➡ 이런 문제를 해결하기 위해 EUC-KR의 확장된 버전으로 마이크로소프트의 **CP949**가 등장했으나 한글 전체를 표현하기에 넉넉한 양은 아니다. 

  - ![image](https://github.com/kikijuju/kikijuju.github.io/assets/114811246/bc3dc74e-f7f6-4c30-bcd4-bf54bed7fe77) 

출처 : https://blog.naver.com/bbmobile/221360230141



#### 4. 유니코드와 UTF-8

- **유니코드** : 여러 나라의 문자를 광범위하게 표현할 수 있는 통일된 문자 집합

  - 유니코드 문자 집합에서는 각 문자마다 고유한 값이 부여된다. 
    - 유니코드 글자에 부여된 값 앞에 U+D55C처럼 U+ 문자열이 붙는 것은 십육진수로 표현할 때 사용
  - 글자에 부여된 값 자체를 인코딩된 값으로 삼지 않고 다양한 방법으로 인코딩한다. 
    - **UTF-8, UTF-16, UTF-32**... ➡ 유니코드 문자에 부여된 값을 인코딩하는 방식

- **UTF-8** 방식 

  - 유니코드 문자에 부여된 값의 범위에 따라 1바이트부터 4바이트까지의 인코딩 결과를 만들어 낸다. 

  <img width="979" alt="image" src="https://github.com/kikijuju/kikijuju.github.io/assets/114811246/b24a80c1-922f-4a64-98a5-72d460e3096a">

출처 : 혼자 공부하는 컴퓨터 구조 + 운영체제 73p 

#### 5. 확인 문제 

1. 아스키 코드 디코딩 
   - 104 111 110 103 111 110 103 ➡ **hongong**

2. EUC-KR 인코딩에 대한 설명이 틀린 것 
   - 조합형 인코딩 방식입니다. ➡ 완성형 인코딩 방식입니다. 

3. 유니코드 문자 집합에서 '안녕'을 UTF-8로 인코딩한 값
   - 3byte 인코딩 
   - '안' ➡ C548(16) = 1100 0101 0100 1000(2) ➡ 11101100 10010101 10001000
   - '녕 ' ➡ B155(16) = 1011 0001 0101 0101(2) ➡ 11101011 10000101 10010101
